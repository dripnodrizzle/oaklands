
-- DungeonHunter Ultimate Remote Inspector & Exploitability Checker
-- Recursively scans all services for remotes, fires/invokes with smart arguments, and listens for OnClientEvent responses


local Services = {
    game:GetService("ReplicatedStorage"),
    game:GetService("Workspace"),
    game:GetService("StarterGui"),
    game:GetService("StarterPack"),
    game:GetService("StarterPlayer"),
    game:GetService("Lighting"),
    game:GetService("Players"),
    game:GetService("SoundService"),
    game:GetService("Chat"),
}
local LocalPlayer = game:GetService("Players").LocalPlayer


local results = {}
local foundRemotes = {}


-- Helper: Listen for OnClientEvent responses
local function listenRemote(remote)
    if remote:IsA("RemoteEvent") then
        remote.OnClientEvent:Connect(function(...)
            print("[OnClientEvent]", remote.Name, ...)
        end)
    end
end

local function isValidIdentifier(str)
    return type(str) == "string" and str:match("^[%a_][%w_]*$")
end

local function testRemote(remoteName, testArgs)
    print("[Checker] Testing remote/variable name:", remoteName)
    if not isValidIdentifier(remoteName) then
        table.insert(results, remoteName .. " is not a valid Lua identifier. Skipped.")
        print("[Checker] Skipped invalid identifier:", remoteName)
        return
    end
    local remote = ReplicatedStorage:FindFirstChild(remoteName)
    if remote and remote:IsA("RemoteEvent") then
        local ok, err = pcall(function()
            remote:FireServer(unpack(testArgs))
        end)
        if ok then
            table.insert(results, remoteName .. " RemoteEvent: Fired with test args.")
        else
            table.insert(results, remoteName .. " RemoteEvent: Error firing: " .. tostring(err))
        end
    elseif remote and remote:IsA("RemoteFunction") then
        local ok, err = pcall(function()
            remote:InvokeServer(unpack(testArgs))
        end)
        if ok then
            table.insert(results, remoteName .. " RemoteFunction: Invoked with test args.")
        else
            table.insert(results, remoteName .. " RemoteFunction: Error invoking: " .. tostring(err))
        end
    else
        table.insert(results, remoteName .. " not found or not a remote.")
    end
end

-- Gold
local goldVars = {"Gold", "EndlessGoldReward", "EndlessGoldReward_2"}
for _, name in ipairs(goldVars) do
    testRemote(name, {999999})
    if isValidIdentifier(name) and LocalPlayer:FindFirstChild(name) then
        print("[Checker] Attempting direct assignment for:", name)
        local success, err = pcall(function()
            LocalPlayer[name].Value = 999999
        end)
        if success then
            table.insert(results, name .. " direct assignment: Success.")
        else
            table.insert(results, name .. " direct assignment: Failed. " .. tostring(err))
        end
    end
end

-- EXP
local expVars = {"MatchExp", "LevelExperience"}
for _, name in ipairs(expVars) do
    testRemote(name, {999999})
    if isValidIdentifier(name) and LocalPlayer:FindFirstChild(name) then
        print("[Checker] Attempting direct assignment for:", name)
        local success, err = pcall(function()
            LocalPlayer[name].Value = 999999
        end)
        if success then
            table.insert(results, name .. " direct assignment: Success.")
        else
            table.insert(results, name .. " direct assignment: Failed. " .. tostring(err))
        end
    end
end

-- Damage/Kill
local dmgVars = {"MatchKill", "MatchDamage", "DamageType", "DamageOrigin"}
for _, name in ipairs(dmgVars) do
    testRemote(name, {999999})
end

-- Loot
local lootVars = {"GetPoolWeight"}
for _, name in ipairs(lootVars) do
    testRemote(name, {"Legendary"})
end

-- Spins (no direct reference, but try common names)
local spinVars = {"Spin", "LotterySpin", "Roll"}
for _, name in ipairs(spinVars) do
    testRemote(name, {999})
end

-- Print results
for _, msg in ipairs(results) do
    print(msg)
end

print("Exploitability check complete.")

-- Utility: Recursively print all RemoteEvents/RemoteFunctions in ReplicatedStorage

local function printAllRemotes(folder, path)
    path = path or folder.Name
    for _, obj in ipairs(folder:GetChildren()) do
        local objPath = path .. "/" .. obj.Name
        if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
            print("[Remote Found]", obj.ClassName, objPath)
            table.insert(foundRemotes, {instance=obj, path=objPath, class=obj.ClassName})
            listenRemote(obj)
        end
        if #obj:GetChildren() > 0 then
            printAllRemotes(obj, objPath)
        end
    end
end



-- Recursively scan all services for remotes
print("\n[Ultimate Checker] Scanning all services for RemoteEvents and RemoteFunctions:")
for _, service in ipairs(Services) do
    print("\n[Service]", service.Name)
    printAllRemotes(service, service.Name)
end

-- Smart argument sets for brute-force testing
local testArgsList = {
    {"BattlePass1"},
    {999999},
    {"Legendary"},
    {{id = 323, extra = "test"}},
    {true},
    {false},
    {nil},
    {"CardDraw"},
    {"VIP"},
    {"Delta"},
    {"Exp"},
    {"Loot"},
    {"Gold"},
    {"Spin"},
    {"Roll"},
    {"Ability"},
    {"ResComboStateChange"},
    {LocalPlayer and LocalPlayer.Name or "Player"},
    {"TestString", 123, true, {nested = "table"}},
}

-- Fire/invoke all found remotes with all argument sets
print("\n[Ultimate Checker] Brute-forcing all found remotes with smart argument sets:")
for _, remoteInfo in ipairs(foundRemotes) do
    local obj = remoteInfo.instance
    for _, testArgs in ipairs(testArgsList) do
        print("[Checker] Attempting to fire/invoke:", remoteInfo.path, "with args:", testArgs[1])
        local ok, err
        if obj:IsA("RemoteEvent") then
            ok, err = pcall(function()
                obj:FireServer(unpack(testArgs))
            end)
        else
            ok, err = pcall(function()
                obj:InvokeServer(unpack(testArgs))
            end)
        end
        if ok then
            print("[Checker] Success:", remoteInfo.path, "Args:", testArgs[1])
        else
            print("[Checker] Error:", remoteInfo.path, "Args:", testArgs[1], err)
        end
        wait(0.1) -- Add a short delay to avoid queue exhaustion and flooding
    end
end
