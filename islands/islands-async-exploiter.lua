-- Islands Async/Promise Exploiter
-- Hook into Islands' promise-based async system

print("Islands Async Exploiter Loading...")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- =====================================================
-- PROMISE DETECTION & HOOKING
-- =====================================================

local PromiseHooker = {}
PromiseHooker.hooks = {}
PromiseHooker.interceptedPromises = {}

-- Find RuntimeLib module (used for async operations)
function PromiseHooker.findRuntimeLib()
    local paths = {
        ReplicatedStorage:WaitForChild("rbxts_include"):FindFirstChild("RuntimeLib"),
    }
    
    for _, module in ipairs(paths) do
        if module then
            print("✓ Found RuntimeLib")
            return require(module)
        end
    end
    
    return nil
end

-- Hook Promise.new to intercept all async operations
function PromiseHooker.hookPromises()
    local RuntimeLib = PromiseHooker.findRuntimeLib()
    if not RuntimeLib then
        warn("RuntimeLib not found - cannot hook promises")
        return false
    end
    
    if not RuntimeLib.Promise then
        warn("Promise not found in RuntimeLib")
        return false
    end
    
    local originalNew = RuntimeLib.Promise.new
    local hookedCount = 0
    
    RuntimeLib.Promise.new = function(executor)
        hookedCount = hookedCount + 1
        local promiseId = hookedCount
        
        print(string.format("[Promise #%d] Created", promiseId))
        
        -- Wrap the executor to log resolution
        local wrappedExecutor = function(resolve, reject)
            local wrappedResolve = function(...)
                local args = {...}
                print(string.format("[Promise #%d] Resolved with %d args", promiseId, #args))
                
                -- Store intercepted data
                table.insert(PromiseHooker.interceptedPromises, {
                    id = promiseId,
                    status = "resolved",
                    args = args,
                    timestamp = tick()
                })
                
                return resolve(...)
            end
            
            local wrappedReject = function(...)
                local args = {...}
                print(string.format("[Promise #%d] Rejected: %s", promiseId, tostring(args[1])))
                
                table.insert(PromiseHooker.interceptedPromises, {
                    id = promiseId,
                    status = "rejected",
                    args = args,
                    timestamp = tick()
                })
                
                return reject(...)
            end
            
            return executor(wrappedResolve, wrappedReject)
        end
        
        return originalNew(wrappedExecutor)
    end
    
    print("✓ Hooked Promise.new")
    return true
end

-- =====================================================
-- MODULE IMPORT INTERCEPTOR
-- =====================================================

local ImportInterceptor = {}
ImportInterceptor.loadedModules = {}

function ImportInterceptor.hookImport()
    local RuntimeLib = PromiseHooker.findRuntimeLib()
    if not RuntimeLib then
        return false
    end
    
    if not RuntimeLib.import then
        warn("import function not found")
        return false
    end
    
    local originalImport = RuntimeLib.import
    
    RuntimeLib.import = function(script, ...)
        local args = {...}
        local path = table.concat(args, "/")
        
        local result = originalImport(script, ...)
        
        -- Log what was imported
        print(string.format("[Import] %s", path))
        
        -- Store module reference
        table.insert(ImportInterceptor.loadedModules, {
            path = path,
            module = result,
            timestamp = tick()
        })
        
        return result
    end
    
    print("✓ Hooked RuntimeLib.import")
    return true
end

-- =====================================================
-- ASYNC FUNCTION ACCELERATOR
-- =====================================================

local AsyncAccelerator = {}

-- Skip all wait() calls by hooking task.wait
function AsyncAccelerator.removeAllWaits()
    local originalWait = task.wait
    
    task.wait = function(duration)
        -- Skip the wait entirely
        return 0
    end
    
    -- Also hook the global wait
    getglobal = getglobal or function(name)
        return _G[name]
    end
    
    local originalGlobalWait = wait
    _G.wait = function(duration)
        return 0
    end
    
    print("✓ Removed all wait() delays")
end

-- Force all promises to resolve immediately (DANGEROUS)
function AsyncAccelerator.instantPromises()
    local RuntimeLib = PromiseHooker.findRuntimeLib()
    if not RuntimeLib or not RuntimeLib.Promise then
        return false
    end
    
    local originalNew = RuntimeLib.Promise.new
    
    RuntimeLib.Promise.new = function(executor)
        -- Execute immediately in synchronous mode
        local resolved = false
        local resolvedValue = nil
        
        executor(
            function(...) -- resolve
                resolved = true
                resolvedValue = {...}
            end,
            function(...) -- reject
                resolved = false
            end
        )
        
        if resolved then
            return {
                await = function() return unpack(resolvedValue) end,
                andThen = function(self, callback) callback(unpack(resolvedValue)) end
            }
        end
        
        return originalNew(executor)
    end
    
    print("✓ Enabled instant promise resolution")
    return true
end

-- =====================================================
-- AWAIT BYPASS
-- =====================================================

local AwaitBypass = {}

-- Hook module.await to log what's being awaited
function AwaitBypass.hookAwait()
    local RuntimeLib = PromiseHooker.findRuntimeLib()
    if not RuntimeLib then
        return false
    end
    
    if not RuntimeLib.await then
        warn("await function not found")
        return false
    end
    
    local originalAwait = RuntimeLib.await
    local awaitCount = 0
    
    RuntimeLib.await = function(promise)
        awaitCount = awaitCount + 1
        print(string.format("[Await #%d] Waiting for promise...", awaitCount))
        
        local startTime = tick()
        local result = originalAwait(promise)
        local elapsed = tick() - startTime
        
        print(string.format("[Await #%d] Completed in %.3fs", awaitCount, elapsed))
        
        return result
    end
    
    print("✓ Hooked RuntimeLib.await")
    return true
end

-- =====================================================
-- UTILITY FUNCTIONS
-- =====================================================

function PromiseHooker.getInterceptedCount()
    return #PromiseHooker.interceptedPromises
end

function PromiseHooker.getLastPromise()
    return PromiseHooker.interceptedPromises[#PromiseHooker.interceptedPromises]
end

function PromiseHooker.dumpPromises()
    print("\n=== Intercepted Promises ===")
    for i, promise in ipairs(PromiseHooker.interceptedPromises) do
        print(string.format("#%d [%s] Age: %.2fs", 
            promise.id, 
            promise.status, 
            tick() - promise.timestamp
        ))
    end
end

function ImportInterceptor.dumpModules()
    print("\n=== Loaded Modules ===")
    for i, mod in ipairs(ImportInterceptor.loadedModules) do
        print(string.format("%d. %s", i, mod.path))
    end
end

-- =====================================================
-- MAIN EXECUTION
-- =====================================================

print("\n=== Islands Async Exploiter ===")

-- Try to hook everything
local success = 0
local total = 4

if PromiseHooker.hookPromises() then success = success + 1 end
if ImportInterceptor.hookImport() then success = success + 1 end
if AwaitBypass.hookAwait() then success = success + 1 end

print(string.format("\n✓ Successfully hooked %d/%d systems", success, total))

print("\n=== Available Commands ===")
print("  PromiseHooker.dumpPromises() - Show all intercepted promises")
print("  ImportInterceptor.dumpModules() - Show all loaded modules")
print("  AsyncAccelerator.removeAllWaits() - Skip all wait() calls")
print("  AsyncAccelerator.instantPromises() - Make promises resolve instantly (DANGEROUS)")

return {
    PromiseHooker = PromiseHooker,
    ImportInterceptor = ImportInterceptor,
    AsyncAccelerator = AsyncAccelerator,
    AwaitBypass = AwaitBypass
}
