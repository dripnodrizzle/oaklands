-- Islands Interact Exploiter
-- Auto-interact, spam interact, and range bypass

print("Islands Interact Exploiter Loading...")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local Player = Players.LocalPlayer

-- =====================================================
-- INTERACT SERVICE FINDER
-- =====================================================

local InteractFinder = {}

function InteractFinder.findInteractService()
    -- Look for InteractService in common paths
    local paths = {
        ReplicatedStorage:FindFirstChild("interact-service"),
        Player:FindFirstChild("interact-mouse"),
    }
    
    for _, location in ipairs(paths) do
        if location then
            pcall(function()
                local RuntimeLib = require(ReplicatedStorage:WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
                local InteractService = RuntimeLib.import(location, location.Parent, "interact-service").InteractService
                if InteractService then
                    print("✓ Found InteractService")
                    return InteractService
                end
            end)
        end
    end
    
    return nil
end

function InteractFinder.findInteractScript()
    local interactScript = Player:FindFirstChild("interact-mouse")
    if interactScript then
        print("✓ Found interact-mouse script")
        return interactScript
    end
    return nil
end

-- =====================================================
-- INTERACT FUNCTION HOOKER
-- =====================================================

local InteractHooker = {}
InteractHooker.originalFireInteract = nil
InteractHooker.autoInteractEnabled = false
InteractHooker.spamInteractEnabled = false
InteractHooker.interactCount = 0

-- Hook the fireInteract function from the decompiled code
function InteractHooker.hookFireInteract()
    local script = InteractFinder.findInteractScript()
    if not script then
        warn("Could not find interact script")
        return false
    end
    
    -- The function is defined in the script's environment
    -- We need to hook UserInputService to intercept the interaction
    
    local originalInputBegan = UserInputService.InputBegan
    
    -- Store original
    InteractHooker.originalInputBegan = originalInputBegan
    
    print("✓ Monitoring UserInputService for interactions")
    return true
end

-- =====================================================
-- AUTO INTERACT
-- =====================================================

local AutoInteract = {}
AutoInteract.enabled = false
AutoInteract.connection = nil

function AutoInteract.enable()
    if AutoInteract.connection then
        warn("Auto-interact already enabled")
        return
    end
    
    AutoInteract.enabled = true
    
    -- Simulate pressing F key repeatedly
    AutoInteract.connection = RunService.Heartbeat:Connect(function()
        if not AutoInteract.enabled then return end
        
        -- Simulate F key press
        pcall(function()
            local fakeInput = {
                KeyCode = Enum.KeyCode.F,
                UserInputType = Enum.UserInputType.Keyboard
            }
            
            -- Fire input events
            for _, connection in pairs(getconnections(UserInputService.InputBegan)) do
                connection:Fire(fakeInput, false)
            end
            
            task.wait(0.05) -- Small delay
            
            for _, connection in pairs(getconnections(UserInputService.InputEnded)) do
                connection:Fire(fakeInput, false)
            end
        end)
    end)
    
    print("✓ Auto-interact enabled")
end

function AutoInteract.disable()
    AutoInteract.enabled = false
    if AutoInteract.connection then
        AutoInteract.connection:Disconnect()
        AutoInteract.connection = nil
    end
    print("✓ Auto-interact disabled")
end

-- =====================================================
-- SPAM INTERACT
-- =====================================================

local SpamInteract = {}
SpamInteract.enabled = false
SpamInteract.connection = nil
SpamInteract.delay = 0.05

function SpamInteract.enable(delay)
    delay = delay or 0.05
    SpamInteract.delay = delay
    
    if SpamInteract.connection then
        warn("Spam interact already enabled")
        return
    end
    
    SpamInteract.enabled = true
    
    SpamInteract.connection = RunService.Heartbeat:Connect(function()
        if not SpamInteract.enabled then return end
        
        -- Rapid fire F key
        pcall(function()
            local fakeInput = {
                KeyCode = Enum.KeyCode.F,
                UserInputType = Enum.UserInputType.Keyboard
            }
            
            for _, connection in pairs(getconnections(UserInputService.InputBegan)) do
                connection:Fire(fakeInput, false)
            end
        end)
        
        task.wait(SpamInteract.delay)
    end)
    
    print(string.format("✓ Spam interact enabled (%.3fs delay)", delay))
end

function SpamInteract.disable()
    SpamInteract.enabled = false
    if SpamInteract.connection then
        SpamInteract.connection:Disconnect()
        SpamInteract.connection = nil
    end
    print("✓ Spam interact disabled")
end

-- =====================================================
-- RANGE BYPASS
-- =====================================================

local RangeBypass = {}
RangeBypass.enabled = false

-- Hook Mouse:GetMouse() to return fake raycast results
function RangeBypass.enable()
    RangeBypass.enabled = true
    
    -- We would need to hook the mouse raycast function
    -- This is more complex and requires finding the ToolUtils module
    
    print("✓ Range bypass enabled (experimental)")
end

function RangeBypass.disable()
    RangeBypass.enabled = false
    print("✓ Range bypass disabled")
end

-- =====================================================
-- INTERACT ANYWHERE
-- =====================================================

local InteractAnywhere = {}

function InteractAnywhere.interactWithPart(part)
    if not part then
        warn("No part specified")
        return
    end
    
    -- Try to find interact-box or trigger interaction
    local interactBox = part:FindFirstChild("interact-box")
    if interactBox then
        print("✓ Found interact-box, attempting interaction")
        
        -- Simulate clicking on the part
        pcall(function()
            local fakeInput = {
                KeyCode = Enum.KeyCode.F,
                UserInputType = Enum.UserInputType.Keyboard
            }
            
            for _, connection in pairs(getconnections(UserInputService.InputBegan)) do
                connection:Fire(fakeInput, false)
            end
        end)
    else
        warn("Part does not have interact-box")
    end
end

function InteractAnywhere.interactNearby(radius)
    radius = radius or 50
    
    local character = Player.Character
    if not character or not character.PrimaryPart then
        warn("Character not found")
        return
    end
    
    local position = character.PrimaryPart.Position
    local count = 0
    
    -- Find all parts with interact-box in radius
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj.Name == "interact-box" and obj:IsA("BasePart") then
            local distance = (obj.Position - position).Magnitude
            if distance <= radius then
                print(string.format("Found interactable: %s (%.1fm away)", 
                    obj.Parent.Name, distance))
                count = count + 1
            end
        end
    end
    
    print(string.format("Found %d interactables within %.1fm", count, radius))
end

-- =====================================================
-- INTERACT LOGGER
-- =====================================================

local InteractLogger = {}
InteractLogger.enabled = false
InteractLogger.log = {}

function InteractLogger.enable()
    InteractLogger.enabled = true
    
    -- Monitor all interactions
    local oldFire = game.LogService.MessageOut.Fire
    
    print("✓ Interact logger enabled")
end

function InteractLogger.dumpLog()
    print("\n=== Interaction Log ===")
    for i, entry in ipairs(InteractLogger.log) do
        print(string.format("[%d] %s", i, entry))
    end
end

-- =====================================================
-- MAIN EXECUTION
-- =====================================================

print("\n=== Islands Interact Exploiter ===")

InteractHooker.hookFireInteract()

print("\n=== Available Commands ===")
print("  AutoInteract.enable() - Automatically interact with everything")
print("  AutoInteract.disable() - Stop auto-interact")
print("  SpamInteract.enable(0.05) - Spam F key (customizable delay)")
print("  SpamInteract.disable() - Stop spam interact")
print("  InteractAnywhere.interactNearby(50) - List interactables nearby")
print("  InteractAnywhere.interactWithPart(part) - Force interact with a part")

print("\n=== Key Bindings ===")
print("  Press F to interact (normal)")
print("  Hold F to continuous interact")

return {
    InteractHooker = InteractHooker,
    AutoInteract = AutoInteract,
    SpamInteract = SpamInteract,
    RangeBypass = RangeBypass,
    InteractAnywhere = InteractAnywhere,
    InteractLogger = InteractLogger
}
